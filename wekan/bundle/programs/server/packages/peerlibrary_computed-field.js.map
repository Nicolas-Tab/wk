{"version":3,"sources":["meteor://ðŸ’»app/packages/peerlibrary:computed-field/lib.js"],"names":["module","export","ComputedField","constructor","func","equalsFunc","dontStop","_","isBoolean","handle","lastValue","autorun","currentView","Package","blaze","Blaze","_isInRender","f","templateInstanceFunc","Template","_currentTemplateInstanceFunc","comp","Tracker","c","_withCurrentView","_withTemplateInstanceFunc","call","stopComputation","stop","onViewDestroyed","onStop","removeViewDestroyedListener","startAutorun","computation","value","ReactiveVar","set","afterFlush","dep","hasDependents","getter","originalStop","flush","get","Object","setPrototypeOf","prototype","__proto__","toString","concat","apply","_isRunning","nonreactive"],"mappings":"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","file":"/packages/peerlibrary_computed-field.js","sourcesContent":["export class ComputedField {\n  constructor(func, equalsFunc, dontStop) {\n    // To support passing boolean as the second argument.\n    if (_.isBoolean(equalsFunc)) {\n      dontStop = equalsFunc;\n      equalsFunc = null;\n    }\n\n    let handle = null;\n    let lastValue = null;\n\n    // TODO: Provide an option to prevent using view's autorun.\n    //       One can wrap code with Blaze._withCurrentView(null, code) to prevent using view's autorun for now.\n    let autorun;\n    const currentView = Package.blaze && Package.blaze.Blaze && Package.blaze.Blaze.currentView\n    if (currentView) {\n      if (currentView._isInRender) {\n        // Inside render we cannot use currentView.autorun directly, so we use our own version of it.\n        // This allows computed fields to be created inside Blaze template helpers, which are called\n        // the first time inside render. While currentView.autorun is disallowed inside render because\n        // autorun would be recreated for reach re-render, this is exactly what computed field does\n        // anyway so it is OK for use to use autorun in this way.\n        autorun = function (f) {\n          const templateInstanceFunc = Package.blaze.Blaze.Template._currentTemplateInstanceFunc;\n\n          const comp = Tracker.autorun((c) => {\n            Package.blaze.Blaze._withCurrentView(currentView, () => {\n              Package.blaze.Blaze.Template._withTemplateInstanceFunc(templateInstanceFunc, () => {\n                f.call(currentView, c);\n              })\n            });\n          });\n\n          const stopComputation = () => {\n            comp.stop();\n          };\n          currentView.onViewDestroyed(stopComputation);\n          comp.onStop(() => {\n            currentView.removeViewDestroyedListener(stopComputation);\n          });\n\n          return comp;\n        };\n\n      }\n      else {\n        autorun = (f) => {\n          return currentView.autorun(f);\n        }\n      }\n    }\n    else {\n      autorun = Tracker.autorun;\n    }\n\n    const startAutorun = function () {\n      handle = autorun(function (computation) {\n        const value = func();\n\n        if (!lastValue) {\n          lastValue = new ReactiveVar(value, equalsFunc);\n        }\n        else {\n          lastValue.set(value);\n        }\n\n        if (!dontStop) {\n          Tracker.afterFlush(function () {\n            // If there are no dependents anymore, stop the autorun. We will run\n            // it again in the getter's flush call if needed.\n            if (!lastValue.dep.hasDependents()) {\n              getter.stop();\n            }\n          });\n        }\n      });\n\n      // If something stops our autorun from the outside, we want to know that and update internal state accordingly.\n      // This means that if computed field was created inside an autorun, and that autorun is invalided our autorun is\n      // stopped. But then computed field might be still around and it might be asked again for the value. We want to\n      // restart our autorun in that case. Instead of trying to recompute the stopped autorun.\n      if (handle.onStop) {\n        handle.onStop(() => {\n          handle = null;\n        });\n      }\n      else {\n        // XXX COMPAT WITH METEOR 1.1.0\n        const originalStop = handle.stop;\n        handle.stop = function () {\n          if (handle) {\n            originalStop.call(handle);\n          }\n          handle = null;\n        };\n      }\n    };\n\n    startAutorun();\n\n    const getter = function () {\n      // We always flush so that you get the most recent value. This is a noop if autorun was not invalidated.\n      getter.flush();\n      return lastValue.get();\n    };\n\n    // We mingle the prototype so that getter instanceof ComputedField is true.\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(getter, this.constructor.prototype);\n    }\n    else {\n      getter.__proto__ = this.constructor.prototype;\n    }\n\n    getter.toString = function() {\n      return `ComputedField{${this()}}`;\n    };\n\n    getter.apply = () => {\n      return getter();\n    };\n\n    getter.call = () => {\n      return getter();\n    };\n\n    // If this autorun is nested in the outside autorun it gets stopped automatically when the outside autorun gets\n    // invalidated, so no need to call destroy. But otherwise you should call destroy when the field is not needed anymore.\n    getter.stop = function () {\n      if (handle != null) {\n        handle.stop();\n      }\n      return handle = null;\n    };\n\n    // For tests.\n    getter._isRunning = () => {\n      return !!handle;\n    };\n\n    // Sometimes you want to force recomputation of the new value before the global Tracker flush is done.\n    // This is a noop if autorun was not invalidated.\n    getter.flush = () => {\n      Tracker.nonreactive(function () {\n        if (handle) {\n          handle.flush();\n        }\n        else {\n          // If there is no autorun, create it now. This will do initial recomputation as well. If there\n          // will be no dependents after the global flush, autorun will stop (again).\n          startAutorun();\n        }\n      })\n    };\n\n    return getter;\n  }\n}\n"]}
{"version":3,"sources":["meteor://ðŸ’»app/packages/aldeed:schema-index/lib/indexing.js"],"names":["SimpleSchema","extendOptions","index","Match","Optional","OneOf","Number","String","Boolean","unique","sparse","version","messages","notUnique","Meteor","isServer","Collection2","on","collection","ss","messageBox","ensureIndex","indexName","startup","_collection","_ensureIndex","background","name","dropIndex","_dropIndex","err","propName","_","each","definition","fieldName","indexValue","idxFieldName","replace","optional"],"mappings":"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","file":"/packages/aldeed_schema-index.js","sourcesContent":["// Extend the schema options allowed by SimpleSchema\nSimpleSchema.extendOptions({\n  index: Match.Optional(Match.OneOf(Number, String, Boolean)),\n  unique: Match.Optional(Boolean),\n  sparse: Match.Optional(Boolean),\n});\n\n// Define validation error messages (legacy)\nif (!SimpleSchema.version || SimpleSchema.version < 2) {\n  SimpleSchema.messages({\n    notUnique: '[label] must be unique',\n  });\n}\n\nif (Meteor.isServer) {\n  Collection2.on('schema.attached', function (collection, ss) {\n    // Define validation error messages\n    if (ss.version >= 2) {\n      ss.messageBox.messages({\n        notUnique: '{{label}} must be unique',\n      });\n    }\n\n    function ensureIndex(index, indexName, unique, sparse) {\n      Meteor.startup(function () {\n        collection._collection._ensureIndex(index, {\n          background: true,\n          name: indexName,\n          unique: unique,\n          sparse: sparse\n        });\n      });\n    }\n\n    function dropIndex(indexName) {\n      Meteor.startup(function () {\n        try {\n          collection._collection._dropIndex(indexName);\n        } catch (err) {\n          // no index with that name, which is what we want\n        }\n      });\n    }\n\n    const propName = ss.version === 2 ? 'mergedSchema' : 'schema';\n\n    // Loop over fields definitions and ensure collection indexes (server side only)\n    _.each(ss[propName](), function(definition, fieldName) {\n      if ('index' in definition || definition.unique === true) {\n        var index = {}, indexValue;\n        // If they specified `unique: true` but not `index`,\n        // we assume `index: 1` to set up the unique index in mongo\n        if ('index' in definition) {\n          indexValue = definition.index;\n          if (indexValue === true) indexValue = 1;\n        } else {\n          indexValue = 1;\n        }\n        var indexName = 'c2_' + fieldName;\n        // In the index object, we want object array keys without the \".$\" piece\n        var idxFieldName = fieldName.replace(/\\.\\$\\./g, \".\");\n        index[idxFieldName] = indexValue;\n        var unique = !!definition.unique && (indexValue === 1 || indexValue === -1);\n        var sparse = definition.sparse || false;\n\n        // If unique and optional, force sparse to prevent errors\n        if (!sparse && unique && definition.optional) sparse = true;\n\n        if (indexValue === false) {\n          dropIndex(indexName);\n        } else {\n          ensureIndex(index, indexName, unique, sparse);\n        }\n      }\n    });\n  });\n}"]}
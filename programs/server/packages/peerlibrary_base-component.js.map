{"version":3,"sources":["meteor://ðŸ’»app/packages/peerlibrary_base-component/lib.coffee","meteor://ðŸ’»app/lib.coffee","meteor://ðŸ’»app/packages/peerlibrary_base-component/debug.coffee","meteor://ðŸ’»app/debug.coffee"],"names":["ComponentsNamespace","addComponentChildDeprecationWarning","arrayReferenceEquals","childrenComponentsDeprecationWarning","childrenComponentsWithDeprecationWarning","componentChildrenDeprecationWarning","componentChildrenWithDeprecationWarning","componentParentDeprecationWarning","createMatcher","createNamespace","getComponent","getNamespace","getPathAndName","removeComponentChildDeprecationWarning","setComponent","hasProp","hasOwnProperty","a","b","i","j","ref","length","propertyOrMatcherOrFunction","matcher","property","_","isString","child","parent","isFunction","assert","isObject","value","COMPONENTS_FIELD","call","name","path","split","pop","components","match","segment","isArray","shift","constructor","namespace","component","name1","BaseComponent","register","componentName","componentClass","Error","equal","componentsNamespace","_componentName","childComponents","nameOrComponent","base","_componentInternals","ReactiveField","len","results1","push","childComponentsWith","results","ComputedField","addChildComponent","childComponent","Tracker","nonreactive","concat","removeChildComponent","without","parentComponent","isUndefined","renderComponent","extendComponent","methods","currentClass","prototype","Object","create","writable","configurable","setPrototypeOf","componentChildren","console","warn","componentChildrenWith","addComponentChild","removeComponentChild","componentParent","childrenComponents","childrenComponentsWith","BaseComponentDebug","startComponent","group","log","endComponent","groupEnd","startMarkedComponent","endMarkedComponent","dumpComponentSubtree","rootComponent","_markComponent","marked","componentRoot","dumpComponentTree","c"],"mappings":"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","file":"/packages/peerlibrary_base-component.js","sourcesContent":["# Comparing arrays of components by reference. This might not be really necessary\n# to do, because all operations we officially support modify length of the array\n# (add a new component or remove an old one). But if somebody is modifying the\n# reactive variable directly we want a sane behavior. The default ReactiveVar\n# equality always returns false when comparing any non-primitive values. Because\n# the order of components in the children array is arbitrary we could further\n# improve this comparison to compare arrays as sets, ignoring the order. Or we\n# could have some canonical order of components in the array.\narrayReferenceEquals = (a, b) ->\n  return false if a.length isnt b.length\n\n  for i in [0...a.length]\n    return false if a[i] isnt b[i]\n\n  true\n\ncreateMatcher = (propertyOrMatcherOrFunction) ->\n  if _.isString propertyOrMatcherOrFunction\n    property = propertyOrMatcherOrFunction\n    propertyOrMatcherOrFunction = (child, parent) =>\n      property of child\n\n  else if not _.isFunction propertyOrMatcherOrFunction\n    assert _.isObject propertyOrMatcherOrFunction\n    matcher = propertyOrMatcherOrFunction\n    propertyOrMatcherOrFunction = (child, parent) =>\n      for property, value of matcher\n        return false unless property of child\n\n        if _.isFunction child[property]\n          return false unless child[property]() is value\n        else\n          return false unless child[property] is value\n\n      true\n\n  propertyOrMatcherOrFunction\n\nclass ComponentsNamespace\n  # We have a special field for components. This allows us to have the namespace with the same name\n  # as a component, without overriding anything in the component (we do not want to use component\n  # object as a namespace object).\n  @COMPONENTS_FIELD: ''\n\ngetPathAndName = (name) ->\n  assert name\n\n  path = name.split '.'\n\n  name = path.pop()\n\n  assert name\n\n  {path, name}\n\ngetNamespace = (components, path) ->\n  assert _.isObject components\n  assert _.isArray path\n\n  match = components\n\n  while (segment = path.shift())?\n    match = match[segment]\n    return null unless _.isObject match\n\n  return null unless _.isObject match\n\n  match or null\n\ncreateNamespace = (components, path) ->\n  assert _.isObject components\n  assert _.isArray path\n\n  match = components\n\n  while (segment = path.shift())?\n    match[segment] = new components.constructor() unless segment of match\n    match = match[segment]\n    assert _.isObject match\n\n  assert _.isObject match\n\n  match\n\ngetComponent = (components, name) ->\n  assert _.isObject components\n\n  return null unless name\n\n  {path, name} = getPathAndName name\n\n  namespace = getNamespace components, path\n  return null unless namespace\n\n  namespace[components.constructor.COMPONENTS_FIELD]?[name] or null\n\nsetComponent = (components, name, component) ->\n  assert _.isObject components\n  assert name\n  assert component\n\n  {path, name} = getPathAndName name\n\n  namespace = createNamespace components, path\n\n  namespace[components.constructor.COMPONENTS_FIELD] ?= new components.constructor()\n  assert name not of namespace[components.constructor.COMPONENTS_FIELD]\n  namespace[components.constructor.COMPONENTS_FIELD][name] = component\n\ncomponentChildrenDeprecationWarning = false\ncomponentChildrenWithDeprecationWarning = false\naddComponentChildDeprecationWarning = false\nremoveComponentChildDeprecationWarning = false\n\ncomponentParentDeprecationWarning = false\n\nchildrenComponentsDeprecationWarning = false\nchildrenComponentsWithDeprecationWarning = false\n\nclass BaseComponent\n  @components: new ComponentsNamespace()\n\n  @register: (componentName, componentClass) ->\n    throw new Error \"Component name is required for registration.\" unless componentName\n\n    # To allow calling @register 'name' from inside a class body.\n    componentClass ?= @\n\n    throw new Error \"Component '#{ componentName }' already registered.\" if getComponent @components, componentName\n\n    # The last condition is to make sure we do not throw the exception when registering a subclass.\n    # Subclassed components have at this stage the same component as the parent component, so we have\n    # to check if they are the same class. If not, this is not an error, it is a subclass.\n    if componentClass.componentName() and componentClass.componentName() isnt componentName and getComponent(@components, componentClass.componentName()) is componentClass\n      throw new Error \"Component '#{ componentName }' already registered under the name '#{ componentClass.componentName() }'.\"\n\n    componentClass.componentName componentName\n    assert.equal componentClass.componentName(), componentName\n\n    setComponent @components, componentName, componentClass\n\n    # To allow chaining.\n    @\n\n  @getComponent: (componentsNamespace, componentName) ->\n    unless componentName\n      componentName = componentsNamespace\n      componentsNamespace = @components\n\n    # If component is missing, just return a null.\n    return null unless componentName\n\n    # But otherwise throw an exception.\n    throw new Error \"Component name '#{ componentName }' is not a string.\" unless _.isString componentName\n\n    getComponent componentsNamespace, componentName\n\n  # Component name is set in the register class method. If not using a registered component and a component name is\n  # wanted, component name has to be set manually or this class method should be overridden with a custom implementation.\n  # Care should be taken that unregistered components have their own name and not the name of their parent class, which\n  # they would have by default. Probably component name should be set in the constructor for such classes, or by calling\n  # componentName class method manually on the new class of this new component.\n  @componentName: (componentName) ->\n    # Setter.\n    if componentName\n      @_componentName = componentName\n      # To allow chaining.\n      return @\n\n    # Getter.\n    @_componentName or null\n\n  # We allow access to the component name through a method so that it can be accessed in templates in an easy way.\n  # It should never be overridden. The implementation should always be exactly the same as class method implementation.\n  componentName: ->\n    # Instance method is just a getter, not a setter as well.\n    @constructor.componentName()\n\n  # The order of components is arbitrary and does not necessary match siblings relations in DOM.\n  # nameOrComponent is optional and it limits the returned children only to those.\n  childComponents: (nameOrComponent) ->\n    @_componentInternals ?= {}\n    @_componentInternals.childComponents ?= new ReactiveField [], arrayReferenceEquals\n\n    # Quick path. Returns a shallow copy.\n    return (child for child in @_componentInternals.childComponents()) unless nameOrComponent\n\n    if _.isString nameOrComponent\n      @childComponentsWith (child, parent) =>\n        child.componentName() is nameOrComponent\n    else\n      @childComponentsWith (child, parent) =>\n        # nameOrComponent is a class.\n        return true if child.constructor is nameOrComponent\n\n        # nameOrComponent is an instance, or something else.\n        return true if child is nameOrComponent\n\n        false\n\n  # The order of components is arbitrary and does not necessary match siblings relations in DOM.\n  # Returns children which pass a predicate function.\n  childComponentsWith: (propertyOrMatcherOrFunction) ->\n    assert propertyOrMatcherOrFunction\n\n    propertyOrMatcherOrFunction = createMatcher propertyOrMatcherOrFunction\n\n    results = new ComputedField =>\n      child for child in @childComponents() when propertyOrMatcherOrFunction.call @, child, @\n    ,\n      arrayReferenceEquals\n\n    results()\n\n  addChildComponent: (childComponent) ->\n    @_componentInternals ?= {}\n    @_componentInternals.childComponents ?= new ReactiveField [], arrayReferenceEquals\n    @_componentInternals.childComponents Tracker.nonreactive =>\n      @_componentInternals.childComponents().concat [childComponent]\n\n    # To allow chaining.\n    @\n\n  removeChildComponent: (childComponent) ->\n    @_componentInternals ?= {}\n    @_componentInternals.childComponents ?= new ReactiveField [], arrayReferenceEquals\n    @_componentInternals.childComponents Tracker.nonreactive =>\n      _.without @_componentInternals.childComponents(), childComponent\n\n    # To allow chaining.\n    @\n\n  parentComponent: (parentComponent) ->\n    @_componentInternals ?= {}\n    # We use reference equality here. This makes reactivity not invalidate the\n    # computation if the same component instance (by reference) is set as a parent.\n    @_componentInternals.parentComponent ?= new ReactiveField null, (a, b) -> a is b\n\n    # Setter.\n    unless _.isUndefined parentComponent\n      @_componentInternals.parentComponent parentComponent\n      # To allow chaining.\n      return @\n\n    # Getter.\n    @_componentInternals.parentComponent()\n\n  @renderComponent: (parentComponent) ->\n    throw new Error \"Not implemented\"\n\n  renderComponent: (parentComponent) ->\n    throw new Error \"Not implemented\"\n\n  @extendComponent: (constructor, methods) ->\n    currentClass = @\n\n    if _.isFunction constructor\n      constructor:: = Object.create currentClass::,\n        constructor:\n          value: constructor\n          writable: true\n          configurable: true\n\n      Object.setPrototypeOf constructor, currentClass\n\n    else\n      methods = constructor\n      constructor = class extends currentClass\n\n    # We expect the plain object of methods here, but if something\n    # else is passed, we use only \"own\" properties.\n    for own property, value of methods or {}\n      constructor::[property] = value\n\n    constructor\n\n  # Deprecated method names.\n  # TODO: Remove them in the future.\n\n  # @deprecated Use childComponents instead.\n  componentChildren: (args...) ->\n    unless componentChildrenDeprecationWarning\n      componentChildrenDeprecationWarning = true\n      console?.warn \"componentChildren has been deprecated. Use childComponents instead.\"\n\n    @childComponents args...\n\n  # @deprecated Use childComponentsWith instead.\n  componentChildrenWith: (args...) ->\n    unless componentChildrenWithDeprecationWarning\n      componentChildrenWithDeprecationWarning = true\n      console?.warn \"componentChildrenWith has been deprecated. Use childComponentsWith instead.\"\n\n    @childComponentsWith args...\n\n  # @deprecated Use addChildComponent instead.\n  addComponentChild: (args...) ->\n    unless addComponentChildDeprecationWarning\n      addComponentChildDeprecationWarning = true\n      console?.warn \"addComponentChild has been deprecated. Use addChildComponent instead.\"\n\n    @addChildComponent args...\n\n  # @deprecated Use removeChildComponent instead.\n  removeComponentChild: (args...) ->\n    unless removeComponentChildDeprecationWarning\n      removeComponentChildDeprecationWarning = true\n      console?.warn \"removeComponentChild has been deprecated. Use removeChildComponent instead.\"\n\n    @removeChildComponent args...\n\n  # @deprecated Use parentComponent instead.\n  componentParent: (args...) ->\n    unless componentParentDeprecationWarning\n      componentParentDeprecationWarning = true\n      console?.warn \"componentParent has been deprecated. Use parentComponent instead.\"\n\n    @parentComponent args...\n\n  # @deprecated Use childComponents instead.\n  childrenComponents: (args...) ->\n    unless componentChildrenDeprecationWarning\n      componentChildrenDeprecationWarning = true\n      console?.warn \"childrenComponents has been deprecated. Use childComponents instead.\"\n\n    @childComponents args...\n\n  # @deprecated Use childComponentsWith instead.\n  childrenComponentsWith: (args...) ->\n    unless componentChildrenWithDeprecationWarning\n      componentChildrenWithDeprecationWarning = true\n      console?.warn \"childrenComponentsWith has been deprecated. Use childComponentsWith instead.\"\n\n    @childComponentsWith args...\n","  // Comparing arrays of components by reference. This might not be really necessary\n  // to do, because all operations we officially support modify length of the array\n  // (add a new component or remove an old one). But if somebody is modifying the\n  // reactive variable directly we want a sane behavior. The default ReactiveVar\n  // equality always returns false when comparing any non-primitive values. Because\n  // the order of components in the children array is arbitrary we could further\n  // improve this comparison to compare arrays as sets, ignoring the order. Or we\n  // could have some canonical order of components in the array.\nvar ComponentsNamespace, addComponentChildDeprecationWarning, arrayReferenceEquals, childrenComponentsDeprecationWarning, childrenComponentsWithDeprecationWarning, componentChildrenDeprecationWarning, componentChildrenWithDeprecationWarning, componentParentDeprecationWarning, createMatcher, createNamespace, getComponent, getNamespace, getPathAndName, removeComponentChildDeprecationWarning, setComponent,               \n  hasProp = {}.hasOwnProperty;\n\narrayReferenceEquals = function(a, b) {\n  var i, j, ref;\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (i = j = 0, ref = a.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\ncreateMatcher = function(propertyOrMatcherOrFunction) {\n  var matcher, property;\n  if (_.isString(propertyOrMatcherOrFunction)) {\n    property = propertyOrMatcherOrFunction;\n    propertyOrMatcherOrFunction = (child, parent) => {\n      return property in child;\n    };\n  } else if (!_.isFunction(propertyOrMatcherOrFunction)) {\n    assert(_.isObject(propertyOrMatcherOrFunction));\n    matcher = propertyOrMatcherOrFunction;\n    propertyOrMatcherOrFunction = (child, parent) => {\n      var value;\n      for (property in matcher) {\n        value = matcher[property];\n        if (!(property in child)) {\n          return false;\n        }\n        if (_.isFunction(child[property])) {\n          if (child[property]() !== value) {\n            return false;\n          }\n        } else {\n          if (child[property] !== value) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n  }\n  return propertyOrMatcherOrFunction;\n};\n\nComponentsNamespace = (function() {\n  class ComponentsNamespace {};\n\n  // We have a special field for components. This allows us to have the namespace with the same name\n  // as a component, without overriding anything in the component (we do not want to use component\n  // object as a namespace object).\n  ComponentsNamespace.COMPONENTS_FIELD = '';\n\n  return ComponentsNamespace;\n\n}).call(this);\n\ngetPathAndName = function(name) {\n  var path;\n  assert(name);\n  path = name.split('.');\n  name = path.pop();\n  assert(name);\n  return {path, name};\n};\n\ngetNamespace = function(components, path) {\n  var match, segment;\n  assert(_.isObject(components));\n  assert(_.isArray(path));\n  match = components;\n  while ((segment = path.shift()) != null) {\n    match = match[segment];\n    if (!_.isObject(match)) {\n      return null;\n    }\n  }\n  if (!_.isObject(match)) {\n    return null;\n  }\n  return match || null;\n};\n\ncreateNamespace = function(components, path) {\n  var match, segment;\n  assert(_.isObject(components));\n  assert(_.isArray(path));\n  match = components;\n  while ((segment = path.shift()) != null) {\n    if (!(segment in match)) {\n      match[segment] = new components.constructor();\n    }\n    match = match[segment];\n    assert(_.isObject(match));\n  }\n  assert(_.isObject(match));\n  return match;\n};\n\ngetComponent = function(components, name) {\n  var namespace, path, ref;\n  assert(_.isObject(components));\n  if (!name) {\n    return null;\n  }\n  ({path, name} = getPathAndName(name));\n  namespace = getNamespace(components, path);\n  if (!namespace) {\n    return null;\n  }\n  return ((ref = namespace[components.constructor.COMPONENTS_FIELD]) != null ? ref[name] : void 0) || null;\n};\n\nsetComponent = function(components, name, component) {\n  var name1, namespace, path;\n  assert(_.isObject(components));\n  assert(name);\n  assert(component);\n  ({path, name} = getPathAndName(name));\n  namespace = createNamespace(components, path);\n  if (namespace[name1 = components.constructor.COMPONENTS_FIELD] == null) {\n    namespace[name1] = new components.constructor();\n  }\n  assert(!(name in namespace[components.constructor.COMPONENTS_FIELD]));\n  return namespace[components.constructor.COMPONENTS_FIELD][name] = component;\n};\n\ncomponentChildrenDeprecationWarning = false;\n\ncomponentChildrenWithDeprecationWarning = false;\n\naddComponentChildDeprecationWarning = false;\n\nremoveComponentChildDeprecationWarning = false;\n\ncomponentParentDeprecationWarning = false;\n\nchildrenComponentsDeprecationWarning = false;\n\nchildrenComponentsWithDeprecationWarning = false;\n\nBaseComponent = (function() {\n  class BaseComponent {\n    static register(componentName, componentClass) {\n      if (!componentName) {\n        throw new Error(\"Component name is required for registration.\");\n      }\n      // To allow calling @register 'name' from inside a class body.\n      if (componentClass == null) {\n        componentClass = this;\n      }\n      if (getComponent(this.components, componentName)) {\n        throw new Error(`Component '${componentName}' already registered.`);\n      }\n      // The last condition is to make sure we do not throw the exception when registering a subclass.\n      // Subclassed components have at this stage the same component as the parent component, so we have\n      // to check if they are the same class. If not, this is not an error, it is a subclass.\n      if (componentClass.componentName() && componentClass.componentName() !== componentName && getComponent(this.components, componentClass.componentName()) === componentClass) {\n        throw new Error(`Component '${componentName}' already registered under the name '${componentClass.componentName()}'.`);\n      }\n      componentClass.componentName(componentName);\n      assert.equal(componentClass.componentName(), componentName);\n      setComponent(this.components, componentName, componentClass);\n      return this;\n    }\n\n    static getComponent(componentsNamespace, componentName) {\n      if (!componentName) {\n        componentName = componentsNamespace;\n        componentsNamespace = this.components;\n      }\n      if (!componentName) {\n        // If component is missing, just return a null.\n        return null;\n      }\n      if (!_.isString(componentName)) {\n        // But otherwise throw an exception.\n        throw new Error(`Component name '${componentName}' is not a string.`);\n      }\n      return getComponent(componentsNamespace, componentName);\n    }\n\n    // Component name is set in the register class method. If not using a registered component and a component name is\n    // wanted, component name has to be set manually or this class method should be overridden with a custom implementation.\n    // Care should be taken that unregistered components have their own name and not the name of their parent class, which\n    // they would have by default. Probably component name should be set in the constructor for such classes, or by calling\n    // componentName class method manually on the new class of this new component.\n    static componentName(componentName) {\n      // Setter.\n      if (componentName) {\n        this._componentName = componentName;\n        // To allow chaining.\n        return this;\n      }\n      // Getter.\n      return this._componentName || null;\n    }\n\n    // We allow access to the component name through a method so that it can be accessed in templates in an easy way.\n    // It should never be overridden. The implementation should always be exactly the same as class method implementation.\n    componentName() {\n      // Instance method is just a getter, not a setter as well.\n      return this.constructor.componentName();\n    }\n\n    // The order of components is arbitrary and does not necessary match siblings relations in DOM.\n    // nameOrComponent is optional and it limits the returned children only to those.\n    childComponents(nameOrComponent) {\n      var base, child;\n      if (this._componentInternals == null) {\n        this._componentInternals = {};\n      }\n      if ((base = this._componentInternals).childComponents == null) {\n        base.childComponents = new ReactiveField([], arrayReferenceEquals);\n      }\n      if (!nameOrComponent) {\n        return (function() {\n          var j, len, ref, results1;\n          ref = this._componentInternals.childComponents();\n          results1 = [];\n          for (j = 0, len = ref.length; j < len; j++) {\n            child = ref[j];\n            // Quick path. Returns a shallow copy.\n            results1.push(child);\n          }\n          return results1;\n        }).call(this);\n      }\n      if (_.isString(nameOrComponent)) {\n        return this.childComponentsWith((child, parent) => {\n          return child.componentName() === nameOrComponent;\n        });\n      } else {\n        return this.childComponentsWith((child, parent) => {\n          if (child.constructor === nameOrComponent) {\n            // nameOrComponent is a class.\n            return true;\n          }\n          if (child === nameOrComponent) {\n            // nameOrComponent is an instance, or something else.\n            return true;\n          }\n          return false;\n        });\n      }\n    }\n\n    // The order of components is arbitrary and does not necessary match siblings relations in DOM.\n    // Returns children which pass a predicate function.\n    childComponentsWith(propertyOrMatcherOrFunction) {\n      var results;\n      assert(propertyOrMatcherOrFunction);\n      propertyOrMatcherOrFunction = createMatcher(propertyOrMatcherOrFunction);\n      results = new ComputedField(() => {\n        var child, j, len, ref, results1;\n        ref = this.childComponents();\n        results1 = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          child = ref[j];\n          if (propertyOrMatcherOrFunction.call(this, child, this)) {\n            results1.push(child);\n          }\n        }\n        return results1;\n      }, arrayReferenceEquals);\n      return results();\n    }\n\n    addChildComponent(childComponent) {\n      var base;\n      if (this._componentInternals == null) {\n        this._componentInternals = {};\n      }\n      if ((base = this._componentInternals).childComponents == null) {\n        base.childComponents = new ReactiveField([], arrayReferenceEquals);\n      }\n      this._componentInternals.childComponents(Tracker.nonreactive(() => {\n        return this._componentInternals.childComponents().concat([childComponent]);\n      }));\n      return this;\n    }\n\n    removeChildComponent(childComponent) {\n      var base;\n      if (this._componentInternals == null) {\n        this._componentInternals = {};\n      }\n      if ((base = this._componentInternals).childComponents == null) {\n        base.childComponents = new ReactiveField([], arrayReferenceEquals);\n      }\n      this._componentInternals.childComponents(Tracker.nonreactive(() => {\n        return _.without(this._componentInternals.childComponents(), childComponent);\n      }));\n      return this;\n    }\n\n    parentComponent(parentComponent) {\n      var base;\n      if (this._componentInternals == null) {\n        this._componentInternals = {};\n      }\n      // We use reference equality here. This makes reactivity not invalidate the\n      // computation if the same component instance (by reference) is set as a parent.\n      if ((base = this._componentInternals).parentComponent == null) {\n        base.parentComponent = new ReactiveField(null, function(a, b) {\n          return a === b;\n        });\n      }\n      // Setter.\n      if (!_.isUndefined(parentComponent)) {\n        this._componentInternals.parentComponent(parentComponent);\n        // To allow chaining.\n        return this;\n      }\n      // Getter.\n      return this._componentInternals.parentComponent();\n    }\n\n    static renderComponent(parentComponent) {\n      throw new Error(\"Not implemented\");\n    }\n\n    renderComponent(parentComponent) {\n      throw new Error(\"Not implemented\");\n    }\n\n    static extendComponent(constructor, methods) {\n      var currentClass, property, ref, value;\n      currentClass = this;\n      if (_.isFunction(constructor)) {\n        constructor.prototype = Object.create(currentClass.prototype, {\n          constructor: {\n            value: constructor,\n            writable: true,\n            configurable: true\n          }\n        });\n        Object.setPrototypeOf(constructor, currentClass);\n      } else {\n        methods = constructor;\n        constructor = class extends currentClass {};\n      }\n      ref = methods || {};\n      for (property in ref) {\n        if (!hasProp.call(ref, property)) continue;\n        value = ref[property];\n        constructor.prototype[property] = value;\n      }\n      return constructor;\n    }\n\n    // Deprecated method names.\n    // TODO: Remove them in the future.\n\n    // @deprecated Use childComponents instead.\n    componentChildren(...args) {\n      if (!componentChildrenDeprecationWarning) {\n        componentChildrenDeprecationWarning = true;\n        if (typeof console !== \"undefined\" && console !== null) {\n          console.warn(\"componentChildren has been deprecated. Use childComponents instead.\");\n        }\n      }\n      return this.childComponents(...args);\n    }\n\n    // @deprecated Use childComponentsWith instead.\n    componentChildrenWith(...args) {\n      if (!componentChildrenWithDeprecationWarning) {\n        componentChildrenWithDeprecationWarning = true;\n        if (typeof console !== \"undefined\" && console !== null) {\n          console.warn(\"componentChildrenWith has been deprecated. Use childComponentsWith instead.\");\n        }\n      }\n      return this.childComponentsWith(...args);\n    }\n\n    // @deprecated Use addChildComponent instead.\n    addComponentChild(...args) {\n      if (!addComponentChildDeprecationWarning) {\n        addComponentChildDeprecationWarning = true;\n        if (typeof console !== \"undefined\" && console !== null) {\n          console.warn(\"addComponentChild has been deprecated. Use addChildComponent instead.\");\n        }\n      }\n      return this.addChildComponent(...args);\n    }\n\n    // @deprecated Use removeChildComponent instead.\n    removeComponentChild(...args) {\n      if (!removeComponentChildDeprecationWarning) {\n        removeComponentChildDeprecationWarning = true;\n        if (typeof console !== \"undefined\" && console !== null) {\n          console.warn(\"removeComponentChild has been deprecated. Use removeChildComponent instead.\");\n        }\n      }\n      return this.removeChildComponent(...args);\n    }\n\n    // @deprecated Use parentComponent instead.\n    componentParent(...args) {\n      if (!componentParentDeprecationWarning) {\n        componentParentDeprecationWarning = true;\n        if (typeof console !== \"undefined\" && console !== null) {\n          console.warn(\"componentParent has been deprecated. Use parentComponent instead.\");\n        }\n      }\n      return this.parentComponent(...args);\n    }\n\n    // @deprecated Use childComponents instead.\n    childrenComponents(...args) {\n      if (!componentChildrenDeprecationWarning) {\n        componentChildrenDeprecationWarning = true;\n        if (typeof console !== \"undefined\" && console !== null) {\n          console.warn(\"childrenComponents has been deprecated. Use childComponents instead.\");\n        }\n      }\n      return this.childComponents(...args);\n    }\n\n    // @deprecated Use childComponentsWith instead.\n    childrenComponentsWith(...args) {\n      if (!componentChildrenWithDeprecationWarning) {\n        componentChildrenWithDeprecationWarning = true;\n        if (typeof console !== \"undefined\" && console !== null) {\n          console.warn(\"childrenComponentsWith has been deprecated. Use childComponentsWith instead.\");\n        }\n      }\n      return this.childComponentsWith(...args);\n    }\n\n  };\n\n  BaseComponent.components = new ComponentsNamespace();\n\n  return BaseComponent;\n\n}).call(this);\n","class BaseComponentDebug\n  @startComponent: (component) ->\n    name = component.componentName() or 'unnamed'\n    console.group name\n    console.log '%o', component\n\n  @endComponent: (component) ->\n    console.groupEnd()\n\n  @startMarkedComponent: (component) ->\n    name = component.componentName() or 'unnamed'\n    console.group '%c%s', 'text-decoration: underline', name\n    console.log '%o', component\n\n  @endMarkedComponent: (component) ->\n    @endComponent component\n\n  @dumpComponentSubtree: (rootComponent, _markComponent=(->)) ->\n    return unless rootComponent\n\n    marked = _markComponent rootComponent\n\n    if marked\n      @startMarkedComponent rootComponent\n    else\n      @startComponent rootComponent\n\n    for child in rootComponent.childComponents()\n      @dumpComponentSubtree child, _markComponent\n\n    if marked\n      @endMarkedComponent rootComponent\n    else\n      @endComponent rootComponent\n\n    return\n\n  @componentRoot: (component) ->\n    while parentComponent = component.parentComponent()\n      component = parentComponent\n\n    component\n\n  @dumpComponentTree: (component) ->\n    return unless component\n\n    @dumpComponentSubtree @componentRoot(component), (c) -> c is component\n","                       \n\nBaseComponentDebug = class BaseComponentDebug {\n  static startComponent(component) {\n    var name;\n    name = component.componentName() || 'unnamed';\n    console.group(name);\n    return console.log('%o', component);\n  }\n\n  static endComponent(component) {\n    return console.groupEnd();\n  }\n\n  static startMarkedComponent(component) {\n    var name;\n    name = component.componentName() || 'unnamed';\n    console.group('%c%s', 'text-decoration: underline', name);\n    return console.log('%o', component);\n  }\n\n  static endMarkedComponent(component) {\n    return this.endComponent(component);\n  }\n\n  static dumpComponentSubtree(rootComponent, _markComponent = (function() {})) {\n    var child, i, len, marked, ref;\n    if (!rootComponent) {\n      return;\n    }\n    marked = _markComponent(rootComponent);\n    if (marked) {\n      this.startMarkedComponent(rootComponent);\n    } else {\n      this.startComponent(rootComponent);\n    }\n    ref = rootComponent.childComponents();\n    for (i = 0, len = ref.length; i < len; i++) {\n      child = ref[i];\n      this.dumpComponentSubtree(child, _markComponent);\n    }\n    if (marked) {\n      this.endMarkedComponent(rootComponent);\n    } else {\n      this.endComponent(rootComponent);\n    }\n  }\n\n  static componentRoot(component) {\n    var parentComponent;\n    while (parentComponent = component.parentComponent()) {\n      component = parentComponent;\n    }\n    return component;\n  }\n\n  static dumpComponentTree(component) {\n    if (!component) {\n      return;\n    }\n    return this.dumpComponentSubtree(this.componentRoot(component), function(c) {\n      return c === component;\n    });\n  }\n\n};\n"]}